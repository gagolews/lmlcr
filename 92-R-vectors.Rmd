<!--
kate: indent-width 4; word-wrap-column 74; default-dictionary en_AU
Copyright (C) 2020-2021, Marek Gagolewski <https://www.gagolewski.com>
This material is licensed under the Creative Commons BY-NC-ND 4.0 License.
-->

# Vector Algebra in R



This chapter is a step-by-step guide to vector computations in R.
It also explains the basic mathematical notation around vectors.

You're encouraged to not only simply *read* the chapter,
but also to execute yourself the R code provided.
Play with it, do some experiments, get curious about
how R works. Read the documentation on the functions you are calling,
e.g., `?seq`, `?sample` and so on.

Technical and mathematical literature isn't belletristic.
It requires *active* (*pro-active* even) thinking.
Sometimes going through a single page can take an hour. Or a day.
If you don't understand something, keep thinking, go back, ask yourself
questions, take a look at other sources. This is not a *linear* process.
This is what makes it fun and creative.
<!--
Or a lifetime, if the material is simply too hard
(let's hope it's not the case with this book!).
-->
To become a good programmer you need a lot of practice, there
are no shortcuts. But the whole endeavour is worth the hassle!




## Motivation

Vector and matrix algebra provides us with a convenient language for
expressing computations on sequential and tabular data.

Vector and matrix algebra operations are supported by every
major programming language -- either natively
(e.g., R, Matlab, GNU Octave, Mathematica)
or via an additional library/package
(e.g, Python with numpy, tensorflow, or pytorch;
C++ with Eigen/Armadillo; C, C++ or Fortran with LAPACK).

By using matrix notation, we generate more concise and readable code.

For instance, given two vectors $\boldsymbol{x}=(x_1,\dots,x_n)$
and $\boldsymbol{y}=(y_1,\dots,y_n)$ like:

```{r motivation1}
x <- c(1.5, 3.5, 2.3,-6.5)
y <- c(2.9, 8.2,-0.1, 0.8)
```

Instead of writing:

```{r motivation2}
s <- 0
n <- length(x)
for (i in 1:n)
    s <- s + (x[i]-y[i])^2
sqrt(s)
```

to mean:

\[
\sqrt{
(x_1-y_1)^2 + (x_2-y_2)^2 + \dots + (x_n-y_n)^2
}
=
\sqrt{\sum_{i=1}^n (x_i-y_i)^2},
\]

which denotes the (Euclidean) distance between the two vectors
(the square root of the sum of squared differences between
the corresponding elements in $\boldsymbol{x}$ and $\boldsymbol{y}$),
we shall soon become used to writing:

```{r motivation3}
sqrt(sum((x-y)^2))
```

or:

\[
\sqrt{(\boldsymbol{x}-\boldsymbol{y})^{T}(\boldsymbol{x}-\boldsymbol{y})}
\]

or even:

\[
\|\boldsymbol{x}-\boldsymbol{y}\|_2
\]

In order to be able to read this notation,
we only have to get to know the most common "building blocks".
There are just a few of them, but it'll take some time until we become comfortable
with their use.

What's more, we should note that vectorised code might be
much faster than the `for` loop-based one (a.k.a. "iterative" style):

```{r motivation4,cache=TRUE}
library("microbenchmark")
n <- 10000
x <- runif(n) # n random numbers in [0,1]
y <- runif(n)
print(microbenchmark(
    t1={
        # "iterative" style
        s <- 0
        n <- length(x)
        for (i in 1:n)
            s <- s + (x[i]-y[i])^2
        sqrt(s)
    },
    t2={
        # "vectorised" style
        sqrt(sum((x-y)^2))
    }
), signif=3, unit='relative')
```



## Numeric Vectors

### Creating Numeric Vectors

First let's introduce a few ways with which we can create numeric vectors.

#### `c()`

The `c()` function *c*ombines a given list of values to form a sequence:

```{r cfun1}
c(1, 2, 3)
c(1, 2, 3, c(4, 5), c(6, c(7, 8)))
```

Note that when we use the assignment operator, `<-` or `=` (both are
equivalent), printing of the output is suppressed:

```{r cfun2}
x <- c(1, 2, 3) # doesn't print anything
print(x)
```

However, we can enforce it by parenthesising the whole expression:

```{r cfun3}
(x <- c(1, 2, 3))
```

In order to determine that `x` is indeed a numeric vector,
we call:

```{r mode_class}
mode(x)
class(x)
```



Remark.

: These two functions might return different results.
For instance, in the next chapter we note that
a numeric matrix will yield `mode()` of `numeric` and
`class()` of `matrix`.


What is more, we can get the number of elements in `x` by calling:

```{r length}
length(x)
```




#### `seq()`


To create an arithmetic progression,
i.e., a sequence of equally-spaced numbers,
we can call the `seq()` function

```{r seq1}
seq(1, 9, 2)
```

If we access the function's documentation (by executing `?seq` in the console),
we'll note that the function takes a couple of parameters:
`from`, `to`, `by`, `length.out` etc.

The above call is equivalent to:

```{r seq2}
seq(from=1, to=9, by=2)
```

The `by` argument can be replaced with `length.out`, which gives the desired
size:

```{r seq3}
seq(0, 1, length.out=5)
```

Note that R supports partial matching of argument names:

```{r seq4}
seq(0, 1, len=5)
```


Quite often we need progressions with step equal to 1 or -1.
Such vectors can be generated by applying the `:` operator.


```{r colon}
1:10     # from:to (inclusive)
-1:-10
```



#### `rep()`

Moreover, `rep()` replicates a given vector.
Check out the function's documentation (see `?rep`) for
the meaning of the arguments provided below.

```{r rep1}
rep(1, 5)
rep(1:3, 4)
rep(1:3, c(2, 4, 3))
rep(1:3, each=4)
```


#### Pseudo-Random Vectors

We can also generate vectors of pseudo-random values.
For instance, the following generates 5 deviates from the uniform distribution
(every number has the same probability) on the unit (i.e., $[0,1]$) interval:

```{r runif}
runif(5, 0, 1)
```

We call such numbers pseudo-random, because they are generated arithmetically.
In fact, by setting the random number generator's state (also called the *seed*),
we can obtain *reproducible* results.

```{r seed}
set.seed(123)
runif(5, 0, 1) # a,b,c,d,e
runif(5, 0, 1) # f,g,h,i,j
set.seed(123)
runif(5, 0, 1) # a,b,c,d,e again!
```


Note the difference between the uniform distribution on $[0,1]$
and the normal distribution with expected value of $0$ and standard deviation
of $1$ (also called the standard normal distribution),
see Figure \@ref(fig:runif-vs-rnorm).

```{r runif-vs-rnorm,cache=TRUE,fig.cap="Uniformly vs. normally distributed random variables"}
par(mfrow=c(1, 2)) # align plots in one row and two columns
hist(runif(10000, 0, 1), col="white", ylim=c(0, 2500)); box()
hist(rnorm(10000, 0, 1), col="white", ylim=c(0, 2500)); box()
```

Another useful function samples a number of values from a given vector,
either with or without replacement:

```{r sample,echo=-1}
set.seed(123)
sample(1:10, 8, replace=TRUE) # with replacement
sample(1:10, 8, replace=FALSE) # without replacement
```

Note that if `n` is a single number,
`sample(n, ...)` is equivalent to `sample(1:n, ...)`.
This is a dangerous behaviour than may lead to bugs in our code.
Read more at `?sample`.



### Vector-Scalar Operations

Mathematically, we sometimes refer to a vector that is reduced to a single component
as a *scalar*. We are used to denoting such objects with lowercase letters
such as $a, b, i, s, x\in\mathbb{R}$.


Remark.

: Note that some programming languages distinguish between
atomic numerical entities and length-one vectors, e.g., `7` vs. `[7]` in Python.
This is not the case in R, where `length(7)` returns 1.




Vector-scalar arithmetic operations
such as $s\boldsymbol{x}$ (multiplication of a vector $\boldsymbol{x}=(x_1,\dots, x_n)$
by a scalar $s$) result in a vector $\boldsymbol{y}$ such that $y_i=s x_i$, $i=1,\dots,n$.

The same rule holds for, e.g., $s+\boldsymbol{x}$, $\boldsymbol{x}-s$, $\boldsymbol{x}/s$.


```{r ops1}
0.5 * c(1, 10, 100)
10 + 1:5
seq(0, 10, by=2)/10
```



By $-\boldsymbol{x}$ we will mean $(-1)\boldsymbol{x}$:

```{r ops2}
-seq(0, 1, length.out=5)
```


Note that in R the same rule applies for exponentiation:

```{r ops3}
(0:5)^2 # synonym: (1:5)**2
2^(0:5)
```

However, in mathematics, we are **not** used  to writing
$2^{\boldsymbol{x}}$ or $\boldsymbol{x}^2$.



### Vector-Vector Operations


Let $\boldsymbol{x}=(x_1,\dots,x_n)$ and $\boldsymbol{y}=(y_1,\dots,y_n)$ be two vectors of identical lengths.

Arithmetic operations $\boldsymbol{x}+\boldsymbol{y}$ and $\boldsymbol{x}-\boldsymbol{y}$ are performed *elementwise*,
i.e., they result in a vector $\boldsymbol{z}$ such that
$z_i=x_i+y_i$ and $z_i=x_i-y_i$, respectively, $i=1,\dots,n$.

```{r ops4}
x <- c(1,  2,   3,    4)
y <- c(1, 10, 100, 1000)
x+y
x-y
```



Although in mathematics we are **not** used to using any special notation
for elementwise multiplication, division and exponentiation, this is available in R.

```{r ops5}
x*y
x/y
y^x
```


Remark.

: `1e+12` is a number written in the *scientific notation*.
It means "1 times 10 to the power of 12", i.e., $1\times 10^{12}$. Physicists
love this notation, because they are used to dealing with very small (think sizes of quarks) and very large (think distances between galaxies) entities.



Moreover, in R the **recycling rule** is applied if we perform elementwise
operations on vectors of *different* lengths -- the shorter
vector is recycled as many times as needed to match the length of the longer
vector, just as if we were performing:

```{r ops6}
rep(1:3, length.out=12) # recycle 1,2,3 to get 12 values
```



Therefore:

```{r ops7}
1:6 * c(1)
1:6 * c(1,10)
1:6 * c(1,10,100)
1:6 * c(1,10,100,1000)
```


Note that a warning is not an error  -- we still get a result
that makes sense.




### Aggregation Functions

R implements a couple of *aggregation* functions:

* `sum(x)` = $\sum_{i=1}^n x_i=x_1+x_2+\dots+x_n$
* `prod(x)` = $\prod_{i=1}^n x_i=x_1 x_2 \dots x_n$
* `mean(x)` = $\frac{1}{n}\sum_{i=1}^n x_i$ -- arithmetic mean
* `var(x)` = `sum((x-mean(x))^2)/(length(x)-1)` =
$\frac{1}{n-1} \sum_{i=1}^n \left(x_i - \frac{1}{n}\sum_{j=1}^n x_j \right)^2$
-- variance
* `sd(x)` = `sqrt(var(x))` -- standard deviation

see also: `min()`, `max()`, `median()`, `quantile()`.


Remark.

: Remember that you can always access the R manual by typing
`?functionname`, e.g., `?quantile`.


Remark.

: Note that $\sum_{i=1}^n x_i$ can also be written
as $\displaystyle\sum_{i=1}^n x_i$ or even $\displaystyle\sum_{i=1,\dots,n} x_i$.
These all mean the sum of $x_i$ for $i$ from $1$ to $n$,
that is, the sum of $x_1$, $x_2$, ..., $x_n$,
i.e.,
$x_1+x_2+\dots+x_n$.

```{r agops,echo=-1}
set.seed(123)
x <- runif(1000)
mean(x)
median(x)
min(x)
max(x)
```


### Special Functions

Furthermore, R supports numerous mathematical functions, e.g.,
`sqrt()`, `abs()`, `round()`, `log()`, `exp()`, `cos()`, `sin()`.
All of them are vectorised -- when applied on a vector of length $n$,
they yield a vector of length $n$ in result.

For example, here is how we can compute the square roots of all the
integers between 1 and 9:

```{r sqrt}
sqrt(1:9)
```


Vectorisation is super-convenient when it comes to, for instance,
plotting (see Figure \@ref(fig:sincos)).

```{r sincos,fig.cap="An example plot of the sine and cosine functions"}
x <- seq(-2*pi, 6*pi, length.out=51)
plot(x, sin(x), type="l")
lines(x, cos(x), col="red") # add a curve to the current plot
```


{ BEGIN exercise }
Try increasing the `length.out` argument to make the curves smoother.
{ END exercise }


### Norms and Distances

Norms are used to measure the *size* of an object.
Mathematically, we will also be interested in the following norms:

* Euclidean norm:
\[
\|\boldsymbol{x}\| = \|\boldsymbol{x}\|_2 = \sqrt{ \sum_{i=1}^n x_i^2 }
\]
this is nothing else than the *length* of the vector $\boldsymbol{x}$
* Manhattan (taxicab) norm:
\[
\|\boldsymbol{x}\|_1 = \sum_{i=1}^n |x_i|
\]
* Chebyshev (maximum) norm:
\[
\|\boldsymbol{x}\|_\infty = \max_{i=1,\dots,n} |x_i|
= \max\{ |x_1|, |x_2|, \dots, |x_n| \}
\]



The above norms can be easily implemented by means of the building blocks
introduced above.  This is super easy:

```{r norms}
z <- c(1, 2)
sqrt(sum(z^2)) # or norm(z, "2"); Euclidean
sum(abs(z))    # Manhattan
max(abs(z))    # Chebyshev
```




Also note that all the norms easily generate the corresponding
*distances* (metrics) between two given points. In particular:

\[
\| \boldsymbol{x}-\boldsymbol{y} \| = \sqrt{
\sum_{i=1}^n \left(x_i-y_i\right)^2
}
\]

gives the *Euclidean distance* (metric) between the two vectors.

```{r distance}
u <- c(1, 0)
v <- c(1, 1)
sqrt(sum((u-v)^2))
```

This is the "normal" distance that you learned at school.



### Dot Product (\*)

What is more, given two vectors of identical lengths,
$\boldsymbol{x}$ and $\boldsymbol{y}$,
we define their *dot product* (a.k.a. *scalar* or *inner product*) as:

\[
\boldsymbol{x}\cdot\boldsymbol{y} = \sum_{i=1}^n x_i y_i.
\]

Let's stress that this is not the same as the
elementwise vector multiplication in R -- the result is a single number.

```{r dotprod}
u <- c(1, 0)
v <- c(1, 1)
sum(u*v)
```


Remark.

: (\*) Note that the squared Euclidean norm of a vector is equal to the dot
product of the vector and itself,
$\|\boldsymbol{x}\|^2 = \boldsymbol{x}\cdot\boldsymbol{x}$.


(\*) Interestingly, a dot product has a nice geometrical interpretation:
\[
\boldsymbol{x}\cdot\boldsymbol{y} = \|\boldsymbol{x}\| \|\boldsymbol{y}\|
\cos\alpha
\]
where $\alpha$ is the angle between the two vectors.
In other words, it is the product of the lengths of the two vectors
and the cosine of the angle between them.
Note that we can get the cosine part by computing the dot product
of the *normalised*
vectors, i.e., such that their lengths are equal to 1.


For example, the two vectors `u` and `v` defined above
can be depicted as in Figure \@ref(fig:vectorplot).

```{r vectorplot,echo=FALSE,fig.cap="Example vectors in 2D"}
plot(rbind(u,v), xlim=c(-0.5, 1.5), ylim=c(-0.5, 1.5), ann=FALSE, asp=1)
arrows(0, 0, u[1], u[2])
arrows(0, 0, v[1], v[2])
text(u[1], u[2], sprintf("[%d,%d]", u[1], u[2]), pos=4)
text(v[1], v[2], sprintf("[%d,%d]", v[1], v[2]), pos=4)
```

We can compute the angle between them by calling:


```{r angle}
(len_u <- sqrt(sum(u^2))) # length == Euclidean norm
(len_v <- sqrt(sum(v^2)))
(cos_angle_uv <- (sum(u*v)/(len_u*len_v))) # cosine of the angle
acos(cos_angle_uv)*180/pi # angle in degs
```



### Missing and Other Special Values

R has a notion of a missing (not-available) value.
It is very useful in data analysis, as we sometimes don't have an information
on an object's feature. For instance, we might not know a patient's age
if he was admitted to the hospital unconscious.

```{r na1}
x <- c(1, 2, NA, 4, 5)
```

Operations on missing values generally result in missing values --
that makes a lot sense.

```{r na2}
x + 11:15
mean(x)
```

If we wish to compute a vector's aggregate after all,
we can get rid of the missing values by calling `na.omit()`:

```{r na3}
mean(na.omit(x)) # mean of non-missing values
```

We can also make use of the `na.rm` parameter of the `mean()` function
(however, not every aggregation function has it -- always refer to documentation).

```{r na4}
mean(x, na.rm=TRUE)
```


Remark.

: Note that in R, a dot has no special meaning.
`na.omit` is as good of a function's name or variable identifier
as `na_omit`, `naOmit`, `NAOMIT`, `naomit` and `NaOmit`.
Note that, however, R is a case-sensitive language -- these are all different
symbols.
Read more in the *Details* section of `?make.names`.


Moreover, some arithmetic operations can result in infinities ($\pm \infty$):

```{r nan1}
log(0)
10^1000 # too large
```

Also, sometimes we'll get a *not-a-number*, `NaN`. This is not a missing value,
but a "invalid" result.

```{r nan2}
sqrt(-1)
log(-1)
Inf-Inf
```




## Logical Vectors

### Creating Logical Vectors

In R there are 3 (!) logical values:
`TRUE`, `FALSE` and geez, I don't know, `NA` maybe?

```{r logic1}
c(TRUE, FALSE, TRUE, NA, FALSE, FALSE, TRUE)
(x <- rep(c(TRUE, FALSE, NA), 2))
mode(x)
class(x)
length(x)
```


Remark.

: By default, `T` is a synonym for `TRUE` and `F` for `FALSE`. This
may be changed though so it's better not to rely on these.


### Logical Operations

Logical operators such as `&` (and) and `|` (or)
are performed in the same manner as arithmetic ones, i.e.:

* they are elementwise operations and
* recycling rule is applied if necessary.

For example,

```{r logic2}
TRUE & TRUE
TRUE & c(TRUE, FALSE)
c(FALSE, FALSE, TRUE, TRUE) | c(TRUE, FALSE, TRUE, FALSE)
```

The `!` operator stands for logical elementwise negation:

```{r logic3}
!c(TRUE, FALSE)
```

Generally, operations on `NA`s yield `NA`  unless other solution
makes sense.

```{r logic4}
u <- c(TRUE, FALSE, NA)
v <- c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, NA, NA, NA)
u & v # elementwise AND (conjunction)
u | v # elementwise OR  (disjunction)
!u    # elementwise NOT (negation)
```


### Comparison Operations

We can compare the corresponding elements of two numeric vectors
and get a logical vector in result.
Operators such as `<` (less than), `<=` (less than or equal),
`==` (equal), `!=` (not equal), `>` (greater than) and `>=` (greater than or equal)
are again elementwise and use the recycling rule if necessary.


```{r logic5}
3 < 1:5 # c(3, 3, 3, 3, 3) < c(1, 2, 3, 4, 5)
1:2 == 1:4 # c(1,2,1,2) == c(1,2,3,4)
z <- c(0, 3, -1, 1, 0.5)
(z >= 0) & (z <= 1)
```



### Aggregation Functions


Also note the following operations on *logical* vectors:

```{r logic6}
z <- 1:10
all(z >= 5) # are all values TRUE?
any(z >= 5) # is there any value TRUE?
```


Moreover:

```{r logic7}
sum(z >= 5) # how many TRUE values are there?
mean(z >= 5) # what is the proportion of TRUE values?
```

The behaviour of `sum()` and `mean()` is dictated by the fact
that, when interpreted in numeric terms, `TRUE` is interpreted as
numeric `1`  and `FALSE` as `0`.

```{r logic8}
as.numeric(c(FALSE, TRUE))
```


Therefore in the example above we have:

```{r logic9}
z >= 5
as.numeric(z >= 5)
sum(as.numeric(z >= 5)) # the same as sum(z >= 5)
```

Yes, there are 6 values equal to TRUE (or 6 ones after conversion), the sum
of zeros and ones gives the number of ones.


## Character Vectors

### Creating Character Vectors

Individual character strings can be created using double quotes or apostrophes.
These are the elements of character vectors

```{r character1}
(x <- "a string")
mode(x)
class(x)
length(x)
rep(c("aaa", 'bb', "c"), 2)
```


### Concatenating Character Vectors

To join (concatenate) the corresponding elements of two or more character vectors,
we call the `paste()` function:

```{r character2}
paste(c("a", "b", "c"), c("1", "2", "3"))
paste(c("a", "b", "c"), c("1", "2", "3"), sep="")
```

Also note:

```{r character3}
paste(c("a", "b", "c"), 1:3) # the same as as.character(1:3)
paste(c("a", "b", "c"), 1:6) # recycling
paste(c("a", "b", "c"), 1:6, c("!", "?"))
```

### Collapsing Character Vectors


We can also collapse a sequence of strings to a single string:

```{r character4}
paste(c("a", "b", "c", "d"), collapse="")
paste(c("a", "b", "c", "d"), collapse=",")
```



<!-- For more string processing functions, see, e.g., the R package stringi. -->







## Vector Subsetting


### Subsetting with Positive Indices

In order to extract subsets (parts) of vectors, we use the square brackets:

```{r subset1}
(x <- seq(10, 100, 10))
x[1]         # the first element
x[length(x)] # the last element
```

More than one element at a time can also be extracted:

```{r subset2}
x[1:3] # the first three
x[c(1, length(x))] # the first and the last
```


For example, the `order()` function returns the indices of the
smallest, 2nd smallest, 3rd smallest, ..., the largest element in a given vector.
We will use this function when implementing our first classifier.

```{r subset3}
y <- c(50, 30, 10, 20, 40)
(o <- order(y))
```

Hence, we see that the smallest element in `y` is at index 3
and the largest  at index 1:

```{r subset4}
y[o[1]]
y[o[length(y)]]
```

Therefore, to get a sorted version of `y`, we call:

```{r subset5}
y[o] # see also sort(y)
```

We can also obtain the 3 largest elements by calling:

```{r subset6}
y[order(y, decreasing=TRUE)[1:3]]
```


### Subsetting with Negative Indices

Subsetting with a vector of negative indices, *excludes* the elements
at given positions:


```{r subset7}
x[-1] # all but the first
x[-(1:3)]
x[-c(1:3, 5, 8)]
```



### Subsetting with Logical Vectors

We may also subset a vector $\boldsymbol{x}$
of length $n$ with a logical vector $\boldsymbol{l}$ also of length $n$.
The $i$-th element, $x_i$, will be extracted if and only if the corresponding
$l_i$ is true.


```{r subset8}
x[c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE)]
```

This gets along nicely with comparison operators that yield logical vectors
on output.

```{r subset9}
x>50
x[x>50] # select elements in x that are greater than 50
x[x<30 | x>70]
x[x<max(x)] # getting rid of the greatest element
x[x > min(x) & x < max(x)] # return all but the smallest and greatest one
```

Of course, e.g., `x[x<max(x)]` returns a new, independent object.
In order to remove the greatest element in `x` permanently, we can write
`x <- x[x<max(x)]`.





### Replacing Elements


Note that the three above vector indexing schemes (positive,
negative, logical indices) allow for replacing specific elements with new
values.

```{r replace1}
x[-1] <- 10000
x
x[-(1:7)] <- c(1, 2, 3)
x
```


### Other Functions

`head()` and `tail()` return, respectively, a few (6 by default) first and last elements
of a vector.

```{r replace2}
head(x) # head(x, 6)
tail(x, 3)
```

Sometimes the `which()` function can come in handy.
For a given logical vector, it returns all the indices
where `TRUE` elements are stored.

```{r replace3}
which(c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE))
print(y) # recall
which(y>30)
```

Note that `y[y>70]` gives the same result
as `y[which(y>70)]` but is faster (because it involves less operations).

`which.min()` and `which.max()` return the index of the smallest
and the largest element, respectively:

```{r replace4}
which.min(y) # where is the minimum?
which.max(y)
y[which.min(y)] # min(y)
```


`is.na()` indicates which elements are missing values (`NA`s):

```{r replace5}
z <- c(1, 2, NA, 4, NA, 6)
is.na(z)
```

Therefore, to remove them from `z` permanently,
we can write (compare `na.omit()`, see also `is.finite()`):

```{r replace6}
(z <- z[!is.na(z)])
```


## Named Vectors

### Creating Named Vectors

Vectors in R can be *named* -- each element can be assigned a string label.

```{r named1}
x <- c(20, 40, 99, 30, 10)
names(x) <- c("a", "b", "c", "d", "e")
x # a named vector
```


Other ways to create named vectors include:

```{r named2}
c(a=1, b=2, c=3)
structure(1:3, names=c("a", "b", "c"))
```

For instance, the `summary()` function returns a named vector:

```{r named3}
summary(x) # NAMED vector, we don't want this here yet
```

This gives the minimum, 1st quartile (25\%-quantile),
Median (50\%-quantile), aritmetic mean,
3rd quartile (75\%-quantile) and maximum.


Note that `x` is still a numeric vector, we can perform various operations
on it as usual:

```{r named4}
sum(x)
x[x>3]
```


Names can be dropped by calling:

```{r named5}
unname(x)
as.numeric(x) # we need to know the type of x though
```


### Subsetting Named Vectors with Character String Indices

It turns out that extracting elements from a named vector can *also* be
performed by means of a vector of character string indices:

```{r named6}
x[c("a", "d", "b")]
summary(x)[c("Median", "Mean")]
```

<!--
coercion as.numeric
Check out yourself:
sort, rank, unique
-->




## Factors


Factors are *special* kinds of vectors that are frequently used to
store qualitative data, e.g., species, groups, types.
Factors are convenient in situations where we have many observations,
but the number
of distinct (unique) values is relatively small.


> Since R 4.0, the global option `stringsAsFactors` defaults to `FALSE`.
> Before that, functions such as `data.frame()` and `read.csv()`
> used to convert character vectors to factors automatically,
> which could lead to some unpleasant, hard to find bugs.
> Luckily, this is no longer the case.
> However, factor objects are still useful.


### Creating Factors

For example, the following character vector:

```{r factor1,echo=-1}
set.seed(123)
(col <- sample(c("blue", "red", "green"), replace=TRUE, 10))
```

can be converted to a factor by calling:

```{r factor2}
(fcol <- factor(col))
```

Note how different is the way factors are printed out on the console.

### Levels

We can easily obtain the list unique labels:

```{r factor3}
levels(fcol)
```

Those can be re-encoded by calling:

```{r factor4}
levels(fcol) <- c("b", "g", "r")
fcol
```

To create a contingency table (in the form of a named numeric vector,
giving how many values are at each factor level),
we call:

```{r factor5}
table(fcol)
```




### Internal Representation (\*)

Factors have a look-and-feel of character vectors,
however, internally they are represented as integer sequences.


```{r factor6}
class(fcol)
mode(fcol)
as.numeric(fcol)
```

These are always integers from `1` to `M` inclusive,
where `M` is the number of levels.
Their meaning is given by the `levels()` function:
in the example above, the meaning of the codes `1`, `2`, `3` is,
respectively, ```r paste(levels(fcol), collapse=", ")```.




If we wished to generate a factor with a specific order of labels,
we could call:

```{r factor7}
factor(col, levels=c("red", "green", "blue"))
```

We can also assign different labels upon creation of a factor:

```{r factor8}
factor(col, levels=c("red", "green", "blue"), labels=c("r", "g", "b"))
```




Knowing how factors are represented is important when we deal
with factors that are built around data that *look like* numeric.
This is because their conversion to numeric
gives the internal codes, not the actual values:

```{r factor9}
(f <- factor(c(1, 3, 0, 1, 4, 0, 0, 1, 4)))
as.numeric(f) # not necessarily what we want here
as.numeric(as.character(f)) # much better
```


Moreover, that idea is labour-saving in contexts such as plotting
of data that are grouped into different classes.
For instance, here is a scatter plot
for the Sepal.Length and Petal.Width variables in the `iris` dataset (which
is an object of type `data.frame`, see below).
Flowers are of different Species, and we wish to indicate which point belongs
to which class:

```{r irisplot-factors,fig.cap="`as.numeric()` on factors can be used to create different plotting styles"}
which_preview <- c(1, 11, 51, 69, 101) # indexes we show below
iris$Sepal.Length[which_preview]
iris$Petal.Width[which_preview]
iris$Species[which_preview]
as.numeric(iris$Species)[which_preview]
plot(iris$Sepal.Length, # x (it's a vector)
     iris$Petal.Width,  # y (it's a vector)
     col=as.numeric(iris$Species), # colours
     pch=as.numeric(iris$Species)
)
```

The above  (see Figure \@ref(fig:irisplot-factors))
was possible because the Species column is a factor object
with:

```{r irisplot2}
levels(iris$Species)
```

and the meaning of `pch` of 1, 2, 3, ... is "circle", "triangle", "plus", ...,
respectively. What's more, there's a default palette that maps
consecutive integers to different colours:

```{r palette}
palette()
```

Hence, black circles mark irises from the 1st class, i.e., "setosa".




## Lists

Numeric, logical and character vectors are *atomic* objects -- each
component is of the same type. Let's take a look at what happens when
we create an atomic vector out of objects of different types:

```{r list1}
c("nine", FALSE, 7, TRUE)
c(FALSE, 7, TRUE, 7)
```

In each case, we get an object of the most "general" type which is able to
represent our data.


On the other hand, R *lists* are *generalised* vectors.
They can consist of arbitrary R objects, possibly of mixed types --
also other lists.



### Creating Lists

Most commonly, we create a generalised vector by calling the `list()` function.

```{r list2}
(l <- list(1:5, letters, runif(3)))
mode(l)
class(l)
length(l)
```

There's a more compact way to print a list on the console:

```{r list3}
str(l)
```

We can also convert an atomic vector to a list by calling:

```{r list4}
as.list(1:3)
```


### Named Lists

List, like other vectors, may be assigned a `names` attribute.

```{r list5}
names(l) <- c("a", "b", "c")
l
```


### Subsetting and Extracting From Lists

Applying a square brackets operator creates a sub-list, which is
of type list as well.

```{r list6}
l[-1]
l[c("a", "c")]
l[1]
```

Note in the 3rd case we deal with a list of length one, not a numeric vector.



To *extract* (dig into) a particular (single) element, we use double square brackets:

```{r list7}
l[[1]]
l[["c"]]
```

The latter can equivalently be written as:

```{r list8}
l$c
```


### Common Operations

Lists, because of their generality (they can store any kind of object),
have few dedicated operations.
In particular, it neither makes sense to add, multiply, ... two lists together
nor to aggregate them.

However, if we wish to run some operation on each element, we can call
list-apply:

```{r lapply1}
(k <- list(x=runif(5), y=runif(6), z=runif(3))) # a named list
lapply(k, mean)
```

The above computes the mean of each of the three numeric vectors
stored inside list `k`.
Moreover:

```{r lapply2}
lapply(k, range)
```

The built-in function `range(x)` returns `c(min(x), max(x))`.


`unlist()` tries (it might not always be possible)
to unwind a list to a simpler, atomic  form:

```{r lapply3}
unlist(lapply(k, mean))
```



Moreover, `split(x, f)` classifies elements in a vector `x`
into subgroups defined by a factor (or an object coercible to)
of the same length.


```{r split}
x <- c(  1,   2,   3,   4,   5,   6,   7,   8,   9,  10)
f <- c("a", "b", "a", "a", "c", "b", "b", "a", "a", "b")
split(x, f)
```


This is very useful when combined with `lapply()` and `unlist()`.
For instance, here are the mean sepal lengths
for each of the three flower species in the famous `iris` dataset.

```{r unlistsplit}
unlist(lapply(split(iris$Sepal.Length, iris$Species), mean))
```



By the way, if we take a look at the documentation of `?lapply`,
we will note that that this function is defined as `lapply(X, FUN, ...)`.
Here `...` denotes the optional arguments that will be passed to `FUN`.

In other words, `lapply(X, FUN, ...)` returns a list `Y` of length `length(X)`
such that `Y[[i]] <- FUN(X[[i]], ...)` for each `i`.
For example, `mean()` has an additional argument `na.rm` that
aims to remove missing values from the input vector.
Compare the following:

```{r unlistagain}
t <- list(1:10, c(1, 2, NA, 4, 5))
unlist(lapply(t, mean))
unlist(lapply(t, mean, na.rm=TRUE))
```


Of course, we can always pass a custom (self-made) function object as well:

```{r unlistagain2}
min_mean_max <- function(x) {
    # the last expression evaluated in the function's body
    # gives its return value:
    c(min(x), mean(x), max(x))
}
lapply(k, min_mean_max)
```

or, more concisely (we can skip the curly braces here -- they are
normally used to group many expressions into one; also, if we don't plan
to re-use the function again, there's no need to give it a name):


```{r unlistagain3}
lapply(k, function(x) c(min(x), mean(x), max(x)))
```


<!--

TODO: Add OnTrack exercises

-->




## Further Reading


Recommended further reading: [@Rintro]

Other: [@mml], [@rprogdatascience], [@r4ds]
